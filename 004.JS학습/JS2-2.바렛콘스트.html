<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS2-2. 바(var) 렛(let) 콘스트(const)</title>
    <script>
        /****************************************************************
            변수(variable)는 바(var), 렛(let), 콘스트(const)!!

            [ var(variable) ] : 함수영역변수

            1. 함수영역에서 사용할 때만 지역변수
            2. 함수영역 바깥에서 사용하면 전역변수
            3. 전역변수와 같은 이름의 변수를 함수내에서 값을 할당하면 덮어쓰기 됨
                (새로운 값으로 업데이트 되는 것)
            4. 함수영역에서 전역변수와 같은 이름의 변수를 선언하면 다른 지역변수로 
               관리됨 (이렇게 되면 코딩이 매우 혼란스러워짐)
               또는 같은 이름이지만 지역변수로 사용할 수 있다는 장점이 되기도 함
            _________________________________________________________
            
            (지역변수 : Lacal Variable)
             함수 영역내에 선언한 변수
             - 특징 : 다른 함수나 바깥(전역) 영역에서 지역변수를 참조 불가
               (다른 영역에서 사용 불가)

            (전역변수 : Global Variable)   
             함수 밖의 영역에서 선언한 변수
             - 특징 : 어떤 함수에서도 전역변수를 참조 가능
               (아무 함수 영역내에서 사용 가능)
             ->>>> 즉, 전역변수의 값도 변경 가능
             -> 전역변수는 공유하고자 하는 데이터를 저장할 때 사용
             ________________________________________________________

              [ let ] : 블록영역변수 (중괄호는 모두 블록)
                        -> 특정코드블록 if, while, for 등... 당연히 function도     

              1. let으로 변수를 선언하면 전역과 지역을 별도로 관리하여 같은 이름의
                 변수도 별개의 변수로 인식
              2. let 변수는 선언 후 아래쪽에서 사용해야함 ->> 변수 호이스팅 금지
                 (비교 : var는 위에서 호출하고 아래에서 선언 가능 -> 변수의 호이스팅)
                 (참고 : 호이스팅이 되지만 일시적 사각지대(Temporal Dead Zone)에 빠져서
                  변수 할당이 되기 전에는 사용 불가하므로 안되는 것처럼 보임)
              3. 같은 영역에서 같은 이름의 변수를 중복 선언 불가 - 재선언금지
                 ( 비교 : var는 중복 선언시 덮어씀 - 재선언가능 )

             __________________________________________________________                 
              [ const ] : 상수(constant) -> 변하지 않는값 (블록영역변수)

              1. 선언과 동시에 할당해야함!
              2. 한번 할당한 값은 변경불가!
              3. 배열과 객체, 함수를 상수로 만드는 경우가 많다!
                 -> 변경불가는 각 배열형, 객체형, 함수형
                 -> 변경가능은 각 배열값, 객체값, 함수전달값
              4. 기타의 특징은 let과 동일함!(블록단위변수)

        ****************************************************************/



        //////////////////////// var 테스트 ///////////////////////////////

        // JS에서 중괄호 {}란? -> 코드를 묶어주는 영역

        // 1. 함수 중괄호에서 var ////////
        function callMe() {
            // 함수내에서 변수를 선언하면 지역변수
            var usa = "미국";

            console.log("3. 함수안 지역 usa", usa);

            // 함수내에서 전역변수 korea 값 변경
            korea = "코리아";

            console.log("4. 함수안 전역 korea", korea);

            // 함수 내에서 전역 uk 찍기
            console.log("5. 함수안 전역 uk", uk);
            // -> 아래쪽에 같은 이름의 지역 uk를 만드는 순간 
            // 이 변수는 지역변수로 취급됨
            // ->>>> 전역변수 uk와는 ㅂㅂ2
            // 결과 : undefined -> 지역 uk 변수가 할당 전에 출력됨 ->>> 변수 초기화

            var uk = "유케이";
            console.log("6. 함수안 지역 uk", uk);

            // 전역변수에 선언된 uk 변수와 같은 이름의 지역변수 만들기 

            // 선언한 적이 없는 변수를 바로 사용해보기
            rabbit = "토끼";
            console.log("7. 함수 안 선언없는 rabbit", rabbit);

            
        } /////////////////// call Me 함수 ////////////////////////

        // 함수 바깥에서 변수를 선언하면 전역변수
        var korea = "한국";
        var uk = "영국";

        console.log("1. 함수밖 전역 korea", korea);
        console.log("2. 함수밖 전역 uk", uk);
        
        // callMe 함수 호출
        callMe();

        // callMe 함수 호출 후 변수
        // 함수에서 전역 변수 값을 변경했음
        console.log("8. 함수밖 전역 korea", korea);

        // 지역변수를 전역에서 참조불가 에러남
        // console.log("함수밖 지역 usa", usa);
        // Uncaught ReferenceError: usa is not defined

        console.log("9. 함수 밖 선언없는 rabbit", rabbit);
        // -> 선언없이 지역에서 할당한 변수는 전역에 등록됨
        // 변수관리가 어려워지고 나중에 소스관리에 리스크로 작용할 수 있음
        // 선언없이 변수를 사용하지 말 것(권고사항)

        ///////////////////////////////////////////////////////////////

        // 2. if문에서 중괄호 var //////////////////////
        if(true) {
            var who = "누구?"
            console.log("if문 안", who);
        }
        console.log("if문 밖", who);
        // if문의 중괄호 안에서 변수를 선언하면 전역변수와 같음 -> 중괄호가 지역 역할을 못함
        // 함수 블록 내부가 아니라 지역변수로 인정하지 않고 전역변수로 취급

        // 2. if문에서 중괄호 let 비교 //////////////////////
        if(true) {
            let what = "뭬야ㅐ??"
            console.log("if문 안", what);
        }
        // console.log("if문 밖", what);
        // what is not defined
        // if문 중괄호 안의 let은 지역변수므로 바깥에서 못씀


        // 3. for문 중괄호 var ////////////////////////
        for(var i =3; i>0; i--) {
            console.log("for문 안 i", i);
        } // for문
        console.log("for문 밖 i", i);
        // for문의 중괄호도 지역변수 역할을 못함
        
        // 결론 : var는 오직 함수의 중괄호에서만 선언 시 지역변수가 됨
        // var 키워드로 선언된 변수는 함수의 코드 블록만을 지역 스코프로 인정하여 
        // 이를 함수 레벨 스코프(함수영역변수)라 한다.

         // 3. for문 중괄호 let ////////////////////////
        for(let j =3; j>0; j--) {
            console.log("for문 안 j", j);
        } // for문
        // console.log("for문 밖 j", j);
        // j is not defined
        // for문의 소괄호안의 세팅은 중괄호 안으로 들어가므로 let 변수 선언 시 
        // for 중괄호 안에 선언으로 처리
        // -> 따라서 지역변수로 처리됨


        //////////////////////// let, const 테스트 ///////////////////////////////
        var seoul = "서울";
        var jeju = "제주도";
        let toktok = "카톡";
        let sport = "축구";

        //// 중괄호로 블록영역을 만들어 보기 ///////////////////////////////////////

        /**********************************************************************/
        {
            // 블록내부에서 전역변수 찍기 앞
            console.log("블록내부에서 전역변수 찍기 앞");

            console.log("seoul", seoul);
            // 블록에서 블록 재선언
            var seoul = "강남구";
            // 하단에서 변수는 전역으로 다시 선언 할당한 결과
            // var는 재선언, 재할당 가능하며 중괄호가 지역변수로서의 역할을 해주진 않음

            // console.log("jeju", jeju); 
            // let으로 선언한 변수는 선언전 사용불가(호이스팅 금지, 초기화전에 접근 불가)
            // Uncaught ReferenceError: Cannot access 'jeju' before initialization
            // let으로 지역변수 jeju 선언
            let jeju = "마라도";
            // 중괄호 안의 let은 지역변수를 생성
            console.log("jeju", jeju);

            // 전역변수 let으로 선언된 같은 이름의 지역변수 만들기
            let toktok = "라인";
            // 중괄호 바깥의 let 과 구분됨 -> 지역변수로 사용됨
            console.log("toktok", toktok);

            // var 로 전역변수의 let 변수를 다시 선언하기
            // var sport = "배구";
            // Identifier 'sport' has already been declared
            // 전역에 선언된 let 과 같은 이름으로 두번 변수를 선언할 수 없도록 막아줌
            console.log("sport", sport);

            // 선언하지 않은 변수를 할당하기
            myitem = "곰인형";
            console.log("myitem", myitem);
            // 선언없이 사용한 변수는 var로 전역변수 선언됨(함수 안에서도)
            // 변수에 대한 관리가 어려워짐 BAD CASE!!

            ///////////////////////////////
            // 블록내부에서 전역변수 찍기 뒤
            console.log("블록내부에서 전역변수 찍기 뒤");
            console.log("seoul", seoul);
            console.log("jeju", jeju);
            console.log("toktok", toktok);
            console.log("sport", sport);
            
            
        }
        /**********************************************************************/
        // 블록 바깥에서 전역변수 찍기
        console.log("블록바깥에서 전역변수 찍기");
        console.log("seoul", seoul);
        console.log("jeju", jeju);
        console.log("toktok", toktok);
        console.log("sport", sport);
        console.log("myitem", myitem);

        ////////////////////////////////////////////////////////////////////

        /////// 변수 호이스팅(Variable Hoisting) /////
        cat = "고양이"; // 변수할당먼저
        console.log("cat", cat);
        var cat; // 변수선언 나중

        // 위에서 변수에 uk의 경우와 마찬가지
        // 변수 선언을 아래서 하는 허용은 var에서만 가능 
        // 문제 : 코딩순서의 혼란 야기

        /// let은 변수 호이스팅을 허용하는가?
        let dog;
        dog = "강아지";
        console.log("dog", dog);
        // let dog;
        // Cannot access 'dog' before initialization
        // let 은 변수 호이스팅을 금지함
        // 변수의 선언과 할당에 대한 철저한 순서를 지킬 수 있음 

        var cat = "먼치킨";
        console.log(cat);
        // var 재선언 가능
        // let dog = "웰시코기"; -> 에러남
        // let 재선언 불가 -> let 쓰는 이유 중 하나


        ///////////////////////////// 상수(constant) 테스트 //////////////////////
        const fish = "고등어";
        console.log("상수 fish", fish);
        // 원칙 1 : 상수는 선언과 동시에 할당해야함
        // const fish; / fish = "고등어"; -> 이런 구조 불가(let은 가능함)
        // fish = "삼치";
        // 원칙 2 : 상수는 재할당 불가
        // Assignment to constant variable.

        ////////// 상수는 바꾸지 않을 값에서 사용
        ////////// 상수는 배열, 객체, 함수를 할당하여 많이 사용!

        ////////////////////////////////////////////////////////////////////////
        ///// const의 활용 : 배열, 객체, 함수 ////////////////////////////////////

        const arr = ["상추", "고기", "마늘"];
        console.log("배열값", arr);
        console.log(arr[3]); // undefined 출력
        // arr = "닭고기"; 
        // Assignment to constant variable.-> 재할당 시도시 에러

        // 베열값 추가
        arr.push("닭고기");
        console.log("배열값2", arr);
        console.log(arr[3]); // 닭고기 값 출력

        // 배열값은 변경가능하지만 새로운 데이터로 재할당 불가

        // [ 2. 객체 ]
        const obj = {name : "김수현"};
        console.log("객체 obj", obj);

        // 재할당 불가
        // obj = 100;

        // 객체에 속성 추가 //
        // 추가방법 : Object 객체의 속성 정의 메서드 사용 //
        // Object.defineProperty(객체명, 속성명, {value:속성값});

        Object.defineProperty(obj, "weight", {value:"74kg"});
        console.log("객체 obj", obj);

        // 객체에 속성 추가 2
        obj.work = "별그대";
        console.log("객체 obj", obj);

        // [ 3. 함수 ]////////////////////////////
        const fn = function(txt){
            console.log("나는 함수당", txt);
        } //// 

        // 함수호출    
        fn("메롱");

        // 그 밖에 배열, 객체, 함수 외에 요소를 담을 경우에도 많이 사용
        // 이유 : 실수로 재할당될 위험에서 지키기 위함 또는 보안상 이유로 많이 사용











        
        
        
    </script>
</head>
<body>
    
</body>
</html>