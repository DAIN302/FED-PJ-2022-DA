<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>03.퍼센트로딩중</title>
    <style>
        /* 로딩중 이미지 */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
        }

        /* 화면에 넣을 이미지 */
        .timg {
            width: 100%;
        }

        /* 원을 담는 박스 */
        .btns {
            width: 15vw;
            aspect-ratio: 1/1;
            background-image: linear-gradient(to left, lightyellow, rgb(247, 212, 217), lavender);
            border-radius: 50%;
        }

        /* 비율밀기 */
        .btns::before {
            content: "";
            display: block;
            padding-top: 100%;
        }

        /* svg셋팅 */
        .btns svg {
            position: absolute;
            top: 0;
            /* 부모박스가 패딩탑으로 비율밀기하므로
        앱솔로 부모박스 맨위로 위치고정! 
        svg 자체는 viewBox설정 때문에 채우기 비율유지함!*/
        }

        /* circle 설정 */
        .c1 {
            fill: none;
            /* 채우기-기본색은 검정색(transparent-투명,none-없음) */
            stroke: rgb(255 201 207);
            /* 선색(안쓰면 안나옴) */
            stroke-width: 10;
            /* 선두께는 안쓰면 1px, 단위없으면 px */
            stroke-linecap: round;
            /* 선끝둥글게 */

            stroke-dasharray: 300%;
            /* 데쉬어레이를 50%로 놓고 선,공백이 몇조각나는지 본다!
        50% * 6조각 = 300% 즉, 선으로만 채우는 크기임! */

            stroke-dashoffset: 300%;
            /* 데쉬어레이와 같은 크기를 데쉬옵셋에 주면 시작점이
        밀려서 공백부터 시작함-> 선이 숨겨지는 효과가 생김! */

            /* 트랜지션: 퍼센트 증가에 따른 애니메이션 */
            transition: 0.1s linear;
        }

        /* 퍼센트 글자박스 */
        .txt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5vw;
            text-shadow: 2px 2px 2px #ccc;
            color: #fff;
        }

    </style>
    <!-- 제이쿼리 라이브러리 CDN -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
    <!-- 제이쿼리 UI CDN -->
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.2/jquery-ui.min.js"></script>
    <script>
        $(()=>{
        // const btns = $(".btns");
        let btns;
        // $(()=>btns=$(".btns"));
        // body에 넣을 이미지 주소 
        const isrc = [
            "https://img.freepik.com/free-vector/night-ocean-landscape-full-moon-stars-shine_107791-7397.jpg?w=2000",
            "https://marketplace.canva.com/EAE-xnqWvJk/1/0/1600w/canva-retro-smoke-and-round-light-desktop-wallpapers-JLofAI27pCg.jpg",
            "https://images3.alphacoders.com/131/1311991.jpeg",
            "https://www.grafico.com.au/assets/uploads/MelbourneMap.jpg",
        ];

        /*******************************************************************
            [ 로딩중 표시는 어떤 기준으로 하는가? ]
            - 로드이벤트 종류에 따라 아래 2가지
            1. DOMContentLoaded
            - html태그만 모두 그려지면 발생
            2. load
            - 대상 내부의 이미 넣은 태그의 컨텐츠가 
            모두 로딩되면 발생(이미지 내용, 동영상내용)

            -> 위의 개념을 볼 때 load 이벤트 구역을 사용해야 할 것 같으나 
            JS로 만들어서 동적으로 생성하는 태그 요소를 모두 로딩할 때까지
            기다려야함
            그러나 일반 load 이벤트는 이것을 체크 못함

            promise를 사용해야함
            promise구역에 태그 로드 코드를 넣어서 기다리게 한 후 로딩되면 다음을 실행

            [ 로딩중 표시 방법 ]
            1. 태그를 넣기 전 로딩중 이미지(혹은 바)를 먼저 실행
            2. 태그 넣기 함수 실행(promise안에 위치)
            3. 로딩 후 promise then 또는 async/await 를 사용한 로딩중 이미지 없애기 실행

        *******************************************************************/

        // 이벤트 발생 확인
        // JS실행구역 -> DOMContentLoaded -> load
        // window.addEventListener("DOMContentLoaded", ()=>{
            // body가 로딩되면 체크
            document.body.onload = () => {
                console.log("body로딩완료")

            } // load

            //로딩중 이미지 넣기 함수
            const firstDo = () =>{
                document.body.innerHTML += `
                <div class="btns loading">
                    <!-- 숫자퍼센트박스 -->
                    <span class="txt"><b class="ptxt">0</b>%</span>
                    <!-- svg박스 -->
                    <svg viewBox="0 0 200 200">
                        <circle
                            class="c1"
                            cx="100"
                            cy="100"
                            r="95"
                            transform="rotate(-90,100,100)"
                        ></circle>
                    </svg>
                </div>
                `
                btns = $(".btns");
                
                // 프로그레스 함수 호출
                progFn(0, 80);
            }


            // 페이지에 많은 양의 이미지 넣기 함수
            const addImg = () =>{
                // 4개의 이미지를 200번 반복해서 800개 이미지 넣기
                for(let i=0; i<200;i++) {
                    isrc.forEach(v=>{
                        document.body.innerHTML += `
                            <img class="timg" src="${v}" alt="test"/>
                        `
                    })
                }
                
            }

            
            // 이미지 컨텐츠를 로딩하는 함수를 Promise하자
            // async/await를 사용
            // async function안에 프라미스 세계 만들어줌
            async function setIt(fn){ // fn 실행코드 함수
                let doit = new Promise(function(success){ // 성공 시 호출 함수
                    // 이미지 넣기 함수 호출
                    // 시간이 걸리는 코드 넣기
                    // addImg();
                    fn();
                    // 위에 있는 코드가 다 실행되면 아래코드를 호출
                    success("다됐엉");
                }) // doit 프라미스

                // 프라미스가 보장하는 코드 실행 후 실행 함수
                const thenDoit = (txt) =>{ // txt에는 success에서 전달한 값 받음
                    console.log("이게머야",txt)

                    // 로딩바 없애기
                    document.querySelector(".loading").remove();
                } //// thenDoit
                // 프라미스 호출하기(await 사용)
                thenDoit(await doit);
                // 실행순서 
                // await 뒤에 doit 함수를 먼저 호출
                // doit은 프라미스 생성자 함수
                // doit에서 시간이 걸리는 코드가 모두 끝나면
                // success() 가 실행 그것은 
                // thenDoit 함수는 success가 리턴해주는 값을 받을 때까지 기다림
            } /// async function

            // 먼저 위에서 로딩표시 이미지 보이기 함수 호출
            firstDo();
            // async/await는 반드시 바깥에서 호출 필수!
            // 약간의 시차를 줌
            // setTimeout(()=>setIt(addImg), 100);
            // setTimeout 쓴 이유 : 실행처리 구역 구분을 위해
            // 로딩바와 실행처리구역을 구분하여 로딩바 이미지가 처리 이미지와 같이 처리되지 않도록
            // 비동기적으로 처리해야 로딩바가 별도로 화면에 먼저 나타날 수 있음
            
            console.log("DOM로드")
        // })

        
            
            /*************************************************
                함수명 : progFn    
                기능 : 퍼센트 증가에 따른 숫자 및 그래프 변경
             *************************************************/
        
            function progFn(seq, pers){ // seq - 버튼 순번, pers - 설정 %값
                //btns = $(".btns")
                // const btns = $(".btns");
                // 개별 숫자 텍스트 읽어오기
                let ptxt = btns.eq(seq).find(".ptxt");
                let num = ptxt.text(); // 문자형 숫자
                //  퍼센트 증가
                num++; // 문자형숫자는 숫자형으로 자동변환됨
    
                // 개별 숫자 반영
                ptxt.text(num);
    
                // 300% -> 0% 
                // 300을 최대수로 볼때 백분율로 변경 
                // 계산식 : 최대수 * 적용할%/100 = 결과 %        
    
                // 계산하기 
                let calc = (300 * (100-num))/100;
                // 계산법 : 전체옵션값 * (100%-현재%)/100
                // 100%-현재%로 계산한 이유는 300에서부터 숫자가 거꾸로 0까지 작아져야 하므로 
    
                // 첫번째 퍼센트원 진행
                btns.eq(seq).find("circle").css({
                    strokeDashoffset : calc + "%"
                })
    
                // 재귀호출 -> 기준수보다 작을 떄까지
                // 기준수의 숫자가 원하는 %가 됨
                if(num < pers) {
                    // 바로 부르기보다 시차두어서 호출하기 위해 setTimeout 사용
                    setTimeout(()=>{
                        progFn(seq, pers);
                    }, 10);
                }
            } /////// progFn
        })
        
        console.log("JS시작")
    </script>
</head>
<body>
    
</body>
</html>